/*
    This file is part of darts – the Dartmouth Academic Ray Tracing Skeleton.

    Copyright (c) 2017-2022 by Wojciech Jarosz

    This file are adapted from PBRTv4, it's copyright follows:

        pbrt is Copyright(c) 1998-2020 Matt Pharr, Wenzel Jakob, and Greg Humphreys.
        The pbrt source code is licensed under the Apache License, Version 2.0.
        SPDX: Apache-2.0
*/

#pragma once

#include <cstdio>
#include <limits>
#include <string>

/** \addtogroup Utilities
    @{
*/

/** \name Gathering and reporting runtime statistics

    Darts makes it very easy to gather runtime statistics about what happens during the executation of the program. This
    functionality is largely based off of that in PBRT and adapted to our codebase.

    Using the below macros, you can easily create statistics that you'd like to track during execution, and have
    summaries printed out after rendering. Available statitic types include:
     - Integer counter (#STAT_COUNTER), optionally formatted as an amount of memory (#STAT_MEMORY_COUNTER)
     - A fractional value which can be reported either as a ratio (#STAT_RATIO) or as a percentage (#STAT_PERCENT)
     - A distribution of floating point (#STAT_FLOAT_DISTRIBUTION) or integer (#STAT_INT_DISTRIBUTION) values

    These macros take a string that will be used as a title in the statistics report returned by #stats_report(), and
    the names(s) for the global variables to create for tracking this statistic.

    For instance, to keep track of the number of camera rays traced during rendering we call the following macro at the
    top of %camera.cpp to create a counter:

    \code{.cpp}
    STAT_COUNTER("Integrator/Camera rays traced", num_camera_rays);
    \endcode

    This creates a global variable named `num_camera_rays`. During rendering we can simply increment it:

    \code{.cpp}
    ++num_camera_rays
    \endcode

    whenever we trace a new camera ray.

    At the end of rendering, this will be reported as follows (assuming we print the report generated by
    #stats_report):

    \code{.sh}
——————————————————————————————————————————————————————————————————————————
 Statistics:
——————————————————————————————————————————————————————————————————————————
  Integrator
    Camera rays traced                                            3002370
——————————————————————————————————————————————————————————————————————————
    \endcode

    @{
*/

class StatsAccumulator;
struct StatRegisterer
{
    /// Function pointer called to accumulate statistics
    using AccumFunc = void (*)(StatsAccumulator &);

    StatRegisterer(AccumFunc func);

    static void call_callbacks(StatsAccumulator &accum);
};

class StatsAccumulator
{
public:
    // StatsAccumulator Public Methods
    StatsAccumulator();

    void report_counter(const char *name, int64_t val);
    void report_memory_counter(const char *name, int64_t val);
    void report_percentage(const char *name, int64_t num, int64_t denom);
    void report_ratio(const char *name, int64_t num, int64_t denom);

    void report_int_distribution(const char *name, int64_t sum, int64_t count, int64_t min, int64_t max);
    void report_float_distribution(const char *name, double sum, int64_t count, double min, double max);

    std::string report();
    void        clear();

private:
    // StatsAccumulator Private Data
    struct Stats;
    Stats *stats = nullptr;
};

/**
    Return a string containing a report about all globally registered statistics.

    Must call #accumulate_thread_stats() from every thread that may have modified the statistics before generating the
    statistics report.
*/
std::string stats_report();

/**
    Clear all statistics.

    Call this if you'd like to restart gathering statistics during different stages of execution of your program (e.g.
    rendering multiple images).
*/
void clear_stats();

/**
    Accumulate the statistics gathered in separate threads together.

    Must call this before generating the statistics report using #stats_report().

    You will need to run this function from the main thread, and from each worker thread that may have updated
   statistics. You can do this easily using code like this:

    \code{.cpp}
    accumulate_thread_stats();                // main thread
    for_each_thread(accumulate_thread_stats); // worker threads
    spdlog::info(stats_report());
    clear_stats();
    \endcode
*/
void accumulate_thread_stats();

/**
    Create a thread-safe integer statistic counting some quantity.

    \warning Should only be called from a .cpp file (never from a .h file that could be included in more than one
    compilation unit).

    \param title    The string containing the name for the statistic
    \param var      A variable name to store the statistic
*/
#define STAT_COUNTER(title, var)                                                                                       \
    static thread_local int64_t var;                                                                                   \
    static StatRegisterer       STATS_REG##var(                                                                        \
        [](StatsAccumulator &accum)                                                                              \
        {                                                                                                        \
            accum.report_counter(title, var);                                                                    \
            var = 0;                                                                                             \
        });
/**
    Create a thread-safe integer statistic counting memory usage

    \copydetails STAT_COUNTER()
*/
#define STAT_MEMORY_COUNTER(title, var)                                                                                \
    static thread_local int64_t var;                                                                                   \
    static StatRegisterer       STATS_REG##var(                                                                        \
        [](StatsAccumulator &accum)                                                                              \
        {                                                                                                        \
            accum.report_memory_counter(title, var);                                                             \
            var = 0;                                                                                             \
        });

struct StatIntDistribution
{
    int64_t sum = 0, count = 0;
    int64_t min = std::numeric_limits<int64_t>::max();
    int64_t max = std::numeric_limits<int64_t>::lowest();
    void    operator<<(int64_t value)
    {
        sum += value;
        count += 1;
        min = (value < min) ? value : min;
        max = (value > max) ? value : max;
    }
};

/**
    Create a thread-safe statistic keeping track of a distribution of integer values.

    \copydetails STAT_COUNTER()
*/
#define STAT_INT_DISTRIBUTION(title, var)                                                                              \
    static thread_local StatIntDistribution var;                                                                       \
    static StatRegisterer                   STATS_REG##var(                                                            \
        [](StatsAccumulator &accum)                                                                  \
        {                                                                                            \
            accum.report_int_distribution(title, var.sum, var.count, var.min, var.max);              \
            var.sum   = 0;                                                                           \
            var.count = 0;                                                                           \
            var.min   = int64_t(std::numeric_limits<int64_t>::max());                                \
            var.max   = int64_t(std::numeric_limits<int64_t>::lowest());                             \
        });

/**
    Create a thread-safe statistic keeping track of a distribution of floating-point values.

    \copydetails STAT_COUNTER
*/
#define STAT_FLOAT_DISTRIBUTION(title, var)                                                                            \
    static thread_local StatCounter<double> var##sum;                                                                  \
    static thread_local int64_t             var##count;                                                                \
    static thread_local StatCounter<double> var##min(std::numeric_limits<double>::max());                              \
    static thread_local StatCounter<double> var##max(std::numeric_limits<double>::lowest());                           \
    static StatRegisterer                   STATS_REG##var(                                                            \
        [](StatsAccumulator &accum)                                                                  \
        {                                                                                            \
            accum.report_float_distribution(title, var##sum, var##count, var##min, var##max);        \
            var##sum   = 0;                                                                          \
            var##count = 0;                                                                          \
            var##min   = StatCounter<double>(std::numeric_limits<double>::max());                    \
            var##max   = StatCounter<double>(std::numeric_limits<double>::lowest());                 \
        });

/**
    Create a thread-safe statistic keeping track of a floating point value expressed as a percentage.

    \copydetails STAT_COUNTER()

    \param num_var   A variable name to store the numerator of the percentage
    \param denom_var A variable name to store the denominator of the percentage
*/
#define STAT_PERCENT(title, num_var, denom_var)                                                                        \
    static thread_local int64_t num_var, denom_var;                                                                    \
    static StatRegisterer       STATS_REG##num_var(                                                                    \
        [](StatsAccumulator &accum)                                                                              \
        {                                                                                                        \
            accum.report_percentage(title, num_var, denom_var);                                                  \
            num_var   = 0;                                                                                       \
            denom_var = 0;                                                                                       \
        });

/**
    Create a thread-safe statistic keeping track of a floating point value expressed as a ratio.

    \copydetails STAT_COUNTER()

    \param num_var   A variable name to store the numerator of the ratio
    \param denom_var A variable name to store the denominator of the ratio
*/
#define STAT_RATIO(title, num_var, denom_var)                                                                          \
    static thread_local int64_t num_var, denom_var;                                                                    \
    static StatRegisterer       STATS_REG##num_var(                                                                    \
        [](StatsAccumulator &accum)                                                                              \
        {                                                                                                        \
            accum.report_ratio(title, num_var, denom_var);                                                       \
            num_var   = 0;                                                                                       \
            denom_var = 0;                                                                                       \
        });

/** @}*/

/** @}*/
